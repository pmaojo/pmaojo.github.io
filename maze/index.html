<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaser Maze Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #333; }
    </style>
</head>
<body>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);
        let player;
        let cursors;
        let walls;

        const MAZE_WIDTH = 20;
        const MAZE_HEIGHT = 15;
        const CELL_SIZE = 40;

        function preload() {
            this.load.image('wall', 'https://www.svgrepo.com/show/389696/texture-wall-bricks.svg');
            this.load.image('player', 'https://visualpharm.com/assets/644/F1%20Race%20Car%20Top%20Veiw-595b40b65ba036ed117d4056.svg');
        }

        function create() {
            walls = this.physics.add.staticGroup();

            const maze = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        walls.create(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 'wall')
                            .setScale(CELL_SIZE / 32)
                            .refreshBody();
                    }
                }
            }

            player = this.physics.add.sprite(CELL_SIZE + CELL_SIZE / 2, CELL_SIZE + CELL_SIZE / 2, 'player')
                .setScale(CELL_SIZE / 64);
            player.setCollideWorldBounds(true);

            this.physics.add.collider(player, walls);

            cursors = this.input.keyboard.createCursorKeys();

            // Camera follow player
            this.cameras.main.setBounds(0, 0, MAZE_WIDTH * CELL_SIZE, MAZE_HEIGHT * CELL_SIZE);
            this.cameras.main.startFollow(player, true, 0.08, 0.08);

            // Add some depth to the walls
            walls.children.entries.forEach(wall => {
                wall.setDepth(wall.y);
            });
        }

        function update() {
            player.setVelocity(0);

            if (cursors.left.isDown) {
                player.setVelocityX(-160);
            } else if (cursors.right.isDown) {
                player.setVelocityX(160);
            }

            if (cursors.up.isDown) {
                player.setVelocityY(-160);
            } else if (cursors.down.isDown) {
                player.setVelocityY(160);
            }

            // Update player depth to create a pseudo-3D effect
            player.setDepth(player.y + 1);
        }

        function generateMaze(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const stack = [{x: 1, y: 1}];
            maze[1][1] = 0;

            while (stack.length > 0) {
                const current = stack.pop();
                const neighbors = [
                    {x: current.x + 2, y: current.y, direction: {x: 1, y: 0}},
                    {x: current.x - 2, y: current.y, direction: {x: -1, y: 0}},
                    {x: current.x, y: current.y + 2, direction: {x: 0, y: 1}},
                    {x: current.x, y: current.y - 2, direction: {x: 0, y: -1}}
                ].filter(n => n.x > 0 && n.x < width && n.y > 0 && n.y < height && maze[n.y][n.x] === 1);

                if (neighbors.length > 0) {
                    stack.push(current);
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[next.y][next.x] = 0;
                    maze[current.y + next.direction.y][current.x + next.direction.x] = 0;
                    stack.push(next);
                }
            }

            return maze;
        }
    </script>
</body>
</html>