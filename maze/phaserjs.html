<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>3D Maze Game with Phaser and Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const config = {
            type: Phaser.WEBGL,
            width: window.innerWidth,
            height: window.innerHeight,
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);
        let camera, renderer, scene, maze, controls;

        const MAZE_WIDTH = 20;
        const MAZE_HEIGHT = 20;
        const CELL_SIZE = 1;

        function preload() {
            // Load textures here
        }

        function create() {
            scene = new Phaser.Scene();
            camera = scene.cameras.main;
            renderer = new Phaser.Display.WebGLRenderer({
                width: window.innerWidth,
                height: window.innerHeight,
                scene: scene,
                context: canvas.getContext('webgl')
            });
            renderer.setClearColor(0x000000);

            const loader = new THREE.TextureLoader();
            loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/2294472375_24a3b8ef46_o.jpg', function(texture) {
                scene.background = texture;
            });

            maze = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);
            createMaze3D();

            camera.position.set(CELL_SIZE * 1.5, CELL_SIZE * 1.5, CELL_SIZE * 1.5);
            camera.lookAt(new Phaser.Math.Vector2(CELL_SIZE * 2, CELL_SIZE, CELL_SIZE * 2));

            controls = new Phaser.Cameras.Controls.FixedKeyControl({
                camera: camera,
                left: game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
                right: game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
                up: game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
                down: game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
                speed: 0.1
            });

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
        }

        function update(time, delta) {
            controls.update(delta);

            const speed = 0.05;
            if (controls.left.isDown) {
                camera.position.x -= speed;
            }
            if (controls.right.isDown) {
                camera.position.x += speed;
            }
            if (controls.up.isDown) {
                camera.position.z -= speed;
            }
            if (controls.down.isDown) {
                camera.position.z += speed;
            }

            renderer.render(scene, camera);
        }

        function generateMaze(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const stack = [{x: 1, y: 1}];
            maze[1][1] = 0;

            while (stack.length > 0) {
                const current = stack.pop();
                const neighbors = [
                    {x: current.x + 2, y: current.y, direction: {x: 1, y: 0}},
                    {x: current.x - 2, y: current.y, direction: {x: -1, y: 0}},
                    {x: current.x, y: current.y + 2, direction: {x: 0, y: 1}},
                    {x: current.x, y: current.y - 2, direction: {x: 0, y: -1}}
                ].filter(n => n.x > 0 && n.x < width && n.y > 0 && n.y < height && maze[n.y][n.x] === 1);

                if (neighbors.length > 0) {
                    stack.push(current);
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[next.y][next.x] = 0;
                    maze[current.y + next.direction.y][current.x + next.direction.x] = 0;
                    stack.push(next);
                }
            }

            return maze;
        }

        function createMaze3D() {
            const wallGeometry = new Phaser.Geom.Cube(1, 1, 1);
            const wallMaterial = new Phaser.Material.StandardMaterial();

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        const wall = new Phaser.GameObjects.Cube(wallGeometry, wallMaterial);
                        wall.position.set(x * CELL_SIZE, CELL_SIZE / 2, y * CELL_SIZE);
                        scene.add(wall);
                    }
                }
            }

            const floorGeometry = new Phaser.Geom.PlaneGeometry(MAZE_WIDTH * CELL_SIZE, MAZE_HEIGHT * CELL_SIZE);
            const floorMaterial = new Phaser.Material.StandardMaterial();
            floorMaterial.side = Phaser.Material.Side.Double;

            const floor = new Phaser.GameObjects.PlaneGeometry(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.set((MAZE_WIDTH * CELL_SIZE) / 2 - CELL_SIZE / 2, 0, (MAZE_HEIGHT * CELL_SIZE) / 2 - CELL_SIZE / 2);
            scene.add(floor);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>